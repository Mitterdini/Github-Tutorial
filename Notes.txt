This file is to keep track of important pages and useful notes.

    LP3THW - Learn Python 3 The Hard Way                  >pyhardway<
    KLR    - Kali Linux Revealed                          >kalibook<
    VP     - Violent Python                               >viopy<
    TT     - OWASP Top Ten                                >topten<
================================================================================
Bookmarks:                  page number given by PDF not Book.
    LP3THW (COMPLETE)
    KLR    (P.84)
    Viopy  (P.47)
    TT     (P.7)
================================================================================

~Learn Python3 The Hard Way~
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Notes

    *Use >pydoc< in Linux terminal to search for help with Python
      -search "open", "file", "os", and "sys" for other info
    *Bash Cheat Sheet: https://learncodethehardway.org/unix/bash_cheat_sheet.pdf
    *Reference Manual: https://www.gnu.org/software/bash/manual/bashref/html
    *When using .encode() or .decode()
        ->Remember !DBES!  --> Decode Bytes Encode Strings
        ->Have bytes; Need strings; ==> Decode Bytes
        ->Have strings; Need bytes; ==> Encode Strings
    *When using range()
        ->range(0,3) => 0,1,2
        ->Use it like range(start, up to but not include)
    *Every IF statement should have an ELSE
        ->If the else should never run because it doesn't make sense, then you
          must use a die function in the else that prints out an error message
          and dies. This will help you find many errors.
        ->Never nest IF statements more than two deep
    *Use WHILE loops only to loop forever       -> only in Python
    *Use FOR loops for all other looping
    *DO NOT USE DEBUGGERS
    *Don't code massive files of code before running them
        ->Code a little, run a little, fix a little
    *When you read Python code, watch out for variables that are set new values
        later in a script
    *Use flow charts to help map out "blueprints" for a script
    *When creating a file that you would like to import later, remember that
        it executes the file when importing to the desired file. (I think)
        for example, if there is a print() function in the imported file, it
        will print the line. same for input() etc.
        That being said, **ALWAYS REMEMBER** to try and keep the importing files
        to functions, classes, etc.
    *Object type comparisons should always use isinstance() instead of comparing
        types directly
    *Use ''.startswith() and ''.endswith() instead of string slicing to check
        for prefixes or suffixes
    *Use https://docs.python.org/3/distutils/setupscript.html to learn more
        about creating my own modules
    *Test files must be in the >tests/< directory and must have have an
        extension >_tests.py< for it to be picked up by the >nosetests< command
    *Make a test file for each module you make. Each module must have >test_<
        in leading the function name. for example =>  >def test_example():<
    *To create a virtual environment move to the virtual environment folder:
        >~/.virtual_envs<
        >virtualenv --system-site-packages ~/.virtual_envs/VIRTUAL_ENV_NAME<
        >. ~/.virtual_envs/VIRTUAL_ENV_NAME/bin/activate<
--------------------------------------------------------------------------------
________________________________
    Code lay-out: Yes's and No's|
________________________________|_______________________________________________
__YES__:

# Aligned with opening delimiter.
foo = long_function_name(var_one, var_two,
                         var_three, var_four)

# More indentation included to distinguish this from the rest.
def long_function_name(
        var_one, var_two, var_three,
        var_four):
    print(var_one)

# Hanging indents should add a level.
foo = long_function_name(
    var_one, var_two,
    var_three, var_four)

__NO__:

# Arguments on first line forbidden when not using vertical alignment.
foo = long_function_name(var_one, var_two,
    var_three, var_four)

# Further indentation required as indentation is not distinguishable.
def long_function_name(
    var_one, var_two, var_three,
    var_four):
    print(var_one)

The 4-space rule is optional for continuation lines.

Optional:

# Hanging indents *may* be indented to other than 4 spaces.
foo = long_function_name(
  var_one, var_two,
  var_three, var_four)

__Yes__: import os
     import sys

__No__:  import sys, os

__Yes__:

FILES = [
    'setup.cfg',
    'tox.ini',
    ]
initialize(FILES,
           error=True,
           )

__No__:

FILES = ['setup.cfg', 'tox.ini',]
initialize(FILES, error=True,)

__Yes__:

def f(x): return 2*x

__No__:

f = lambda x: 2*x

________________________________________________________________________________

--------------------------------------------------------------------------------
Pages

    LP3THW (P.65)       Escape Sequences table and '\' uses
    LP3THW (P.292)      Terminal commands and definitions
    LP3THW (P.162-165)  Useful Term Tables
    LP3THW (P.186-7)    Useful Object-Oriented Terms
    LP3THW (P.293-4)    Useful Bash Commands

================================================================================

~Kali Linux Revealed~
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Notes


________________________________________________________________________________
--------------------------------------------------------------------------------

Pages


================================================================================

~Violent Python~
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Notes

________________________________________________________________________________
--------------------------------------------------------------------------------

Pages


================================================================================

~OWASP Top Ten~
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Notes
    *OWASP Application Security Verification Standard (ASVS) {Check when done}
    *https://www.owasp.org/index.php/OWASP_Guide_Project
        and https://www.owasp.org/index.php/OWASP_Cheat_Sheet_Series to find
        more security issues
    *For how to find vulnerabilities check:
        https://www.owasp.org/index.php/OWASP_Testing_Project
    *To stop vulnerabilities check:
        https://www.owasp.org/index.php/OWASP_Proactive_Controls
        and https://www.owasp.org/index.php/ASVS
    *Cross Site Request Forgery:
        https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)
    *OWASP Risk Rating Methodology:
        https://www.owasp.org/index.php/OWASP_Risk_Rating_Methodology
    *Common Weakness Enumeration:
        https://cwe.mitre.org/data/definitions/22.html
    *LDAP = Lightweight Directory Access Protocol
    *Command Injection:
        https://www.owasp.org/index.php/Command_Injection
    *Injection Flaws:
        https://www.owasp.org/index.php/Injection_Flaws


    **Application is Vulerable when**
        -User-supplied data is not validated, filtered, or sanitized by the
            application.
        -Dynamic queries or non-parameterized calls without context-
            aware escaping are used directly in the interpreter.
        -Hostile data is used within object-relational mapping (ORM)
            search parameters to extract additional, sensitive records.
        -Hostile data is directly used or concatenated, such that the
            SQL or command contains both structure and hostile data in
            dynamic queries, commands, or stored procedures.
    **To Prevent**
        -Preventing injection requires keeping data separate from
            commands and queries.
        -The preferred option is to use a safe API, which avoids the use
            of the interpreter entirely or provides a parameterized interface,
            or migrate to use Object Relational Mapping Tools (ORMs).
        -Use positive or "whitelist" server-side input validation. This is
            not a complete defense as many applications require special
            characters, such as text areas or APIs for mobile applications.
        -For any residual dynamic queries, escape special characters
            using the specific escape syntax for that interpreter.
        -Use LIMIT and other SQL controls within queries to prevent
            mass disclosure of records in case of SQL injection.

________________________________________________________________________________
--------------------------------------------------------------------------------

Pages
    *Refer to P.5 for a visual of differences between 2013 and 2017
    *Refer to P.7 for a summary of the top 10

================================================================================

Miscellaneous

    *https://wiki.archlinux.org/index.php/File_permissions_and_attributes
        -> for >ls -Al< to learn what attributes you can use
    *To sort by time in terminal use >ls -tr< or >ls -t<
